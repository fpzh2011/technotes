# The Go Programming Language

The Go Programming Language, Alan A. A. Donovan · Brian W. Kernighan （https://docs.ruanjiadeng.com/gopl-zh/ch1/ch1-01.html）
https://github.com/golang-china/gopl-zh

Go是一门编译型语言，而且是静态编译（CH1.1）。

Go语言的代码通过包（package）组织，包类似于其它语言里的库（libraries）或者模块（modules）。一个包由位于单个目录下的一个或多个.go源代码文件组成, 目录定义包的作用。每个源文件都以一条package声明语句开始（CH1.1）。

main包比较特殊。它定义了一个独立可执行的程序，而不是一个库。在main包里的main函数也很特殊，它是整个程序执行时的入口（CH1.1）。

Go语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。实际上，编译器会主动把特定符号（应该不包括花括号）后的换行符转换为分号, 因此换行符添加的位置会影响Go代码的正确解析（CH1.2）。

Go语言不允许使用无用的局部变量（local variables），因为这会导致编译错误。

## 变量

### 命名

关键字列表（CH2.1）。
一个名字如果是在函数外部定义，那么将在当前包的所有文件中都可以访问（CH2.1）。
名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的，那么它将是导出的，也就是说可以被外部的包访问（CH2.1）。
在习惯上，Go语言程序员推荐使用 驼峰式 命名。

### 声明

Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明（CH2.2）。
包一级的各种类型的声明语句的顺序无关紧要（译注：函数内部的名字则必须先声明之后才能使用）。（CH2.2）

### 变量（2.3）

如果初始化表达式被省略，那么将用零值初始化该变量。 数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、map、chan和函数）变量对应的零值是nil。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。（CH2.3）
**在Go语言中不存在未初始化的变量。**（CH2.3）

一行语句可以声明多个类型不同的变量（CH2.3）：
```go
var b, f, s = true, 2.3, "four" // bool, float64, string
```

在包级别声明的变量会在main入口函数执行前完成初始化，局部变量将在声明语句被执行到的时候完成初始化。一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化。（CH2.3）

在函数内部，`:=`可以不带`var`关键字，但是需要在声明同时初始化（P5）。
简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在相同的词法域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了。如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。（CH2.3.1）

### 指针（CH 2.3.2）

Go语言提供了指针。&操作符可以返回一个变量的内存地址，并且*操作符可以获取指针指向的变量内容，但是在Go语言里没有指针运算，也就是不能像c语言里可以对指针进行加或减操作（CH1.8）。

即使变量由表达式临时生成，那么表达式也必须能接受&取地址操作。（CH2.3.2）


### new函数（CH 2.3.3）

用new创建变量和普通变量声明语句方式创建变量没有什么区别，new函数类似是一种语法糖。
另外参考CH 2.3.4, 2.3.3。

### 变量的生命周期（CH 2.3.4）

垃圾回收：
Go语言的自动圾收集器是如何知道一个变量是何时可以被回收的呢？基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。

因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。
编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。

也就是说，在函数中定义的局部变量，未必会在栈中分配内存；函数中通过new创建的变量，也未必会在堆中分配内存。

## 切片Slice

切片是Go语言的基础概念（P4）。

### 赋值（CH 2.4）

译注：自增和自减是语句，而不是表达式，因此`x = i++`之类的表达式是错误的。

### 元组赋值（CH 2.4.1）

```go
x, y = y, x
f, err = os.Open("foo.txt")
```

### 类型（CH 2.5）

一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的（不能直接赋值，必须强制类型转换后才能赋值）。
```go
type 类型名字 底层类型
```
对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型。
只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身。

底层数据类型决定了内部结构和表达方式，也决定是否可以像底层类型一样对内置运算符的支持。

命名类型还可以为该类型的值定义新的行为。（第六章）


### 包的初始化（CH 2.6.2）

init初始化函数。

每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依然的包都已经完成初始化工作了。

### 作用域（CH 2.7）

一个声明语句将程序中的实体和一个名字关联，比如一个函数或一个变量。声明语句的作用域是指源代码中可以有效使用这个名字的范围。
不要将**作用域**和**生命周期**混为一谈。声明语句的作用域对应的是一个源代码的文本区域；它是一个**编译时**的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个**运行时**的概念。
语法块决定了内部声明的名字的作用域范围。

声明语句对应的词法域决定了作用域范围的大小。对于内置的类型、函数和常量，比如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用。
任何在在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问的。
对于导入的包，则是对应源文件级的作用域。当前包的其它源文件无法访问在当前源文件导入的包。

当编译器遇到一个名字引用时，如果它看起来像一个声明，它首先从最内层的词法域向全局的作用域查找。内部的一个声明可能屏蔽外部的声明。

在包级别，声明的顺序并不会影响作用域范围，因此一个先声明的可以引用它自身或者是引用后面的一个声明。

**要特别注意短变量声明语句的作用域范围。**（参考本节最后的例子）

## 基础数据类型（CH3）

Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。
基础类型，包括：数字、字符串和布尔型。
复合数据类型包括数组和结构体——是通过组合简单类型，来表达更加复杂的数据结构。
引用类型包括指针、切片字典、函数、通道，它们都是对程序中一个变量或状态的间接引用。这意味着对任一引用类型数据的修改都会影响所有该引用的拷贝。

## 整型（CH 3.1）

rune类型是和int32等价的类型，通常用于表示一个Unicode码点。这两个名称可以互换使用。
无符号的整数类型uintptr，没有指定具体的bit大小但是足以容纳指针。

算术、逻辑运算符优先级。位运算符，`&^`位清空运算符。
在Go语言中，`%`取模运算符的符号和被取模数的符号总是一致的。

Go语言倾向于使用有符号的int类型，比如处理逆序循环。

一般来说，需要一个显式的转换将一个值从一种类型转化位另一种类型，并且算术和逻辑运算的二元操作中必须是相同的类型。

fmt的输出技巧：
```go
fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)
```
通常`Printf`格式化字符串包含多个`%`参数时将会包含对应相同数量的额外操作数，但是`%`之后的`[1]`副词告诉`Printf`函数再次使用第一个操作数。第二，`%`后的`#`副词告诉`Printf`在用`%o %x %X`输出时生成`0 0x 0X`前缀。

### 浮点数（CH 3.2）

函数math.IsNaN用于测试一个数是否是非数NaN，math.NaN则返回非数对应的值。虽然可以用math.NaN来表示一个非法的结果，但是测试一个结果是否是非数NaN则是充满风险的，因为NaN和任何数都是不相等的（译注：在浮点数中，NaN、正无穷大和负无穷大都不是唯一的，每个都有非常多种的bit模式表示）
如果一个函数返回的浮点数结果可能失败，最好的做法是用单独的标志报告失败。

### 布尔型（CH 3.4）

`&&`的优先级比`||`高。
布尔值并不会隐式转换为数字值0或1，反之亦然。

### 字符串（CH 3.5）

一个字符串是一个**不可改变**的字节序列。字符串可以包含任意的数据，包括byte值0。

内置的`len`函数可以返回一个字符串中的字节数目（不是rune字符数目），索引操作`s[i]`返回第`i`个字节的字节值，`i`必须满足`0 ≤ i< len(s)`条件约束。
第`i`个字节并不一定是字符串的第`i`个字符。

子字符串操作`s[i:j]`基于原始的`s`字符串的第`i`个字节开始到第`j`个字节（并不包含`j`本身）生成一个新字符串。生成的新字符串将包含`j-i`个字节。

不变性意味如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。字符串切片操作代价也是低廉的。

Go语言源文件总是用UTF8编码，并且Go语言的文本字符串也以UTF8编码的方式处理，因此我们可以将Unicode码点也写到字符串面值中。

原生的字符串字面值形式是使用反引号括起来的字符序列。如：
```go
const GoUsage = `Go is a tool for managing Go source code.

Usage:
    go command [arguments]
...`
```

### Unicode & UTF-8（CH 3.5.2/3）

Unicode码点对应Go语言中的rune整数类型，rune是int32等价类型。
每个Unicode码点都使用同样的大小32bit来表示。这种方式比较简单统一，但是它会浪费很多存储空间。
UTF8是一个将Unicode码点编码为字节序列的变长编码。

`unicode`包提供了诸多处理rune字符相关功能的函数（比如区分字母和数组，或者是字母的大写和小写转换等），`unicode/utf8`包则提供了用于rune字符序列的UTF8编码和解码的功能。

Go语言字符串面值中的Unicode转义字符让我们可以通过Unicode码点输入特殊的字符。有两种形式：`\uhhhh`对应16位的码点值，`\Uhhhhhhhh`对应32位的码点值。（字母u，16位码点是小写，32位是大写）

得益于UTF8编码优良的设计，可以直接进行字符串前缀、后缀、子串测试。

UTF8字符串作为交换格式是非常方便的，但是在程序内部采用rune序列可能更方便，因为rune大小一致，支持数组索引和方便切割。

Unicode相关操作：
```go
import "unicode/utf8"

s := "Hello, 世界"
fmt.Println(len(s))                    // "13"
fmt.Println(utf8.RuneCountInString(s)) // "9"

for i := 0; i < len(s); {
	r, size := utf8.DecodeRuneInString(s[i:])
	fmt.Printf("%d\t%c\n", i, r)
	i += size
}

for i, r := range "Hello, 世界" {
	//Go语言的range循环在处理字符串的时候，会自动隐式解码UTF8字符串。
	fmt.Printf("%d\t%q\t%d\n", i, r, r)
}

//utf8.RuneCountInString(s)

//string接受到[]rune的类型转换，可以将一个UTF8编码的字符串解码为Unicode字符序列：
s := "プログラム"
//% x参数用于在每个十六进制数字前插入一个空格
fmt.Printf("% x\n", s) // "e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0"
r := []rune(s)
fmt.Printf("%x\n", r)  // "[30d7 30ed 30b0 30e9 30e0]"
//如果是将一个[]rune类型的Unicode字符slice或数组转为string，则对它们进行UTF8编码
fmt.Println(string(r)) // "プログラム"

//将一个整数转型为字符串意思是生成以只包含对应Unicode码点字符的UTF8字符串
fmt.Println(string(65))     // "A", not "65"
fmt.Println(string(0x4eac)) // "京"
```

### 字符串和Byte切片（CH 3.5.4）

标准库中有四个包对字符串处理尤为重要：bytes、strings、strconv和unicode包。
strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。
bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型。因为字符串是只读的(CH3.5, CH3.5.4)，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用bytes.Buffer类型将会更有效。
strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。
unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。每个函数有一个单一的rune类型的参数，然后返回一个布尔值。而像ToUpper和ToLower之类的转换函数将用于rune字符的大小写转换。
path和path/filepath包提供了关于文件路径名更一般的函数操作。

一个字符串是包含的只读字节数组，一旦创建，是不可变的。相比之下，一个字节slice的元素则可以自由地修改。
字符串和字节slice之间可以相互转换：
```go
s := "abc"
b := []byte(s)
s2 := string(b)
```
从概念上讲，一个[]byte(s)转换是分配了一个新的字节数组用于保存字符串数据的拷贝，然后引用这个底层的字节数组。编译器的优化可以避免在一些场景下分配和复制字符串数据，但总的来说需要确保在变量b被修改的情况下，原始的s字符串也不会改变。将一个字节slice转到字符串的string(b)操作则是构造一个字符串拷贝，以确保s2字符串是只读的。

bytes包还提供了Buffer类型用于字节slice的缓存。一个Buffer开始是空的，但是随着string、byte或[]byte等类型数据的写入可以动态增长。
当向bytes.Buffer添加任意字符的UTF8编码时，最好使用bytes.Buffer的WriteRune方法，但是WriteByte方法对于写入类似'['和']'等ASCII字符则会更加有效。

### 字符串和数字的转换（CH 3.5.5）

strconv包提供这类转换功能。

### 常量（CH 3.6）

每种常量的潜在类型都是基础类型：boolean、string或数字。

**iota 常量生成器**。可以为第一个常量设置一个初始值，后面的常量一次加1，或者依次移位运算。

**无类型常量**。编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算。通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。

## 复合数据类型（CH 4）

## 数组（CH 4.1）

数组是一个由**固定长度**的特定类型元素组成的序列。因为数组的长度是固定的，因此在Go语言中很少直接使用数组。一般使用slice来替代数组。
默认情况下，数组的每个元素都被初始化为元素类型对应的零值。
数组的长度是数组类型的一个组成部分，因此`[3]int`和`[4]int`是两种不同的数组类型。**数组的长度必须是常量表达式**，因为数组的长度需要在编译阶段确定。
如果一个数组的元素类型是可以相互比较的，那么数组类型也是可以相互比较的，可以用`== !=`进行比较。
Go语言中，函数调用中，**数组参数是值传递**，所以，一般用Slice传递参数。（P83）
```go
//与Slice声明的区别是，数组声明时需要明确指定大小
var a [3]int
var r [3]int = [3]int{1, 2} //第3个元素默认初始化为0
q := [...]int{1, 2, 3} //...”省略号，则表示数组的长度是根据初始化值的个数来计算。
//指定元素的索引。注意，这是数组，不是map。“key”必须是无符号整数。初始化索引的顺序是无关紧要的。未指定初始值的元素（如索引0）将用零值初始化。
symbol := [...]string{1: "$", 2: "€", 3: "￡", 4: "￥"} 
```

### Slice 切片（CH 4.2）

Slice（切片）代表**变长**的序列，序列中每个元素都有相同的类型。一个slice类型一般写作`[]T`，其中T代表slice中元素的类型；slice的语法和数组很像，只是没有固定长度而已。

slice的底层引用一个数组对象。一个slice由三个部分构成：指针、长度和容量。指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素。长度对应slice中元素的数目；长度不能超过容量。容量一般是从slice的开始位置到底层数据的结尾位置。内置的len和cap函数分别返回slice的长度和容量。

多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠。

slice的切片操作`s[i:j]`，其中`0 ≤ i≤ j≤ cap(s)`，用于创建一个新的slice。
如果切片操作超出cap(s)的上限将导致一个panic异常，但是超出len(s)则是意味着扩展了slice，因为新slice的长度会变大。

因为slice值包含指向第一个slice元素的指针，因此**向函数传递slice将允许在函数内部修改底层数组的元素**。

**slice之间不能比较**，因此我们不能使用==操作符来判断两个slice是否含有全部相等元素。不过标准库提供了高度优化的bytes.Equal函数来判断两个字节型slice是否相等（[]byte）。但是对于其他类型的slice，我们必须自己展开每个元素进行比较。
slice唯一合法的比较操作是和nil比较。一个零值的slice等于nil。一个nil值的slice并没有底层数组。一个nil值的slice的长度和容量都是0，但是也有非nil值的slice的长度和容量也是0的。
如果你需要测试一个slice是否是空的，使用`len(s) == 0`来判断，而不应该用`s == nil`来判断。
除了和nil相等比较外，一个nil值的slice的行为和其它任意0长度的slice一样；例如reverse(nil)也是安全的。除了文档已经明确说明的地方，所有的Go语言函数应该以相同的方式对待nil值的slice和0长度的slice。

内置的make函数创建一个指定元素类型、长度和容量的slice。容量部分可以省略，在这种情况下，容量将等于长度。
在底层，make创建了一个匿名的数组变量，然后返回一个slice；只有通过返回的slice才能引用底层匿名的数组变量。
```go
make([]T, len)
make([]T, len, cap) // same as make([]T, cap)[:len] //类似于C++的reserve
```

内置的append函数用于向slice追加元素。如果原来的数组空间不足，append函数会重新申请内存、将原数组的数据拷贝到新内存。所以，通常要将append结果显式赋值给原slice。
```go
var runes []rune
for _, r := range "Hello, 世界" {
	runes = append(runes, r)
}
```
要正确地使用slice，需要记住尽管底层数组的元素是间接访问的，但是slice对应结构体本身的指针、长度和容量部分是直接访问的。要更新这些信息需要像上面例子那样一个显式的赋值操作。
内置的append函数则可以追加多个元素，甚至追加一个slice。

内置的copy函数可以方便地将一个slice复制另一个相同类型的slice。copy函数的第一个参数是要复制的目标slice，第二个参数是源slice，目标和源的位置顺序和dst = src赋值语句是一致的。两个slice可以共享同一个底层数组，甚至有重叠也没有问题。copy函数将返回成功复制的元素的个数（我们这里没有用到），等于两个slice中较小的长度，所以我们不用担心覆盖会超出目标slice的范围。

### Map（CH 4.3）

在Go语言中，一个map就是一个哈希表的引用。它是一个**无序**的key/value对的集合，其中所有的key都是不同的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。

map类型可以写为`map[K]V`。其中K对应的key必须是支持`==`比较运算符的数据类型。将浮点数用做key类型则是一个坏的想法，最坏的情况是可能出现的NaN和任何浮点数都不相等。

创建一个map：
```go
ages := make(map[string]int)

ages2 := map[string]int{
    "alice":   31,
    "charlie": 34,
}

ages3 := [string]int{} //创建空的map

delete(ages, "alice") //内置的delete函数可以删除元素

ages["bob"]++

for name, age := range ages {
    fmt.Printf("%s\t%d\n", name, age)
}
```
所有这些操作是安全的，即使这些元素不在map中也没有关系。如果一个查找失败将返回value类型对应的零值。

但是map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作，因为map的存储可能会变动。

map类型的零值是nil，也就是没有**引用**任何哈希表。`var ages map[string]int`创建一个nil的map。
map上的大部分操作，包括查找、删除、len和range循环都可以安全工作在nil值的map上，它们的行为和一个空的map类似。但是向一个nil值的map存入元素将导致一个panic异常。在向map存数据前必须先创建map。

`age, ok := ages["bob"]`可以知道对应的元素是否真的是在map之中。在这种场景下，map的下标语法将产生两个值；第二个是一个布尔值，用于报告元素是否真的存在。

map之间也不能进行相等比较；唯一的例外是和nil进行比较。

可以用map实现类似set的功能。如map[string]bool。

### 结构体（CH 4.4）

可以对结构体成员取地址。Go语言对结构体指针没有`->`操作符，结构体指针也可以使用`.`操作符引用成员。
结构体的指针可以视为引用，因为Go语言自动提供对内存和对象生命周期的管理。

如果结构体成员名字是以大写字母开头的，那么该成员就是导出的。一个结构体可能同时包含导出和未导出的成员。

但是S类型的结构体可以包含`*S`指针类型的成员。

结构体类型的零值是每个成员都是零值。通常会将零值作为最合理的默认值。

**结构体面值**
```go
type Point struct{ X, Y int }
//第一种写法，按位置指定参数
p := Point{1, 2}

//推荐的第二种写法，按名称指定参数。如果成员被忽略的话将默认用零值。
p2 := Point{X:1, Y:2}
```

结构体可以作为函数的参数和返回值。如果考虑效率的话，较大的结构体通常会用指针的方式传入和返回。所以，**结构体参数是值传递**。
因为在Go语言中，**所有的函数参数都是值拷贝传入的**。

如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用`==`或`!=`运算符进行比较。

**结构体嵌入和匿名成员**
Go语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字；这类成员就叫匿名成员。匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。下面的代码中，Circle和Wheel各自都有一个匿名成员。我们可以说Point类型被嵌入到了Circle结构体，同时Circle类型被嵌入到了Wheel结构体。得益于匿名嵌入的特性，我们可以直接访问叶子属性而不需要给出完整的路径：
```go
type Point struct {
    X, Y int
}
type Circle struct {
    Point
    Radius int
}
type Wheel struct {
    Circle
    Spokes int
}

var w Wheel
w.X = 8            // equivalent to w.Circle.Point.X = 8
w.Y = 8            // equivalent to w.Circle.Point.Y = 8
w.Radius = 5       // equivalent to w.Circle.Radius = 5
w.Spokes = 20
w = Wheel{8, 8, 5, 20}                       // compile error: unknown fields
w = Wheel{X: 8, Y: 8, Radius: 5, Spokes: 20} // compile error: unknown fields
```
匿名成员并不是真的无法访问了。其中匿名成员Circle和Point都有自己的名字——就是命名的类型名字——但是这些名字在点操作符中是可选的。我们在访问子成员的时候可以忽略任何匿名成员部分。
不幸的是，结构体字面值并没有简短表示匿名成员的语法。

结构体字面值必须遵循形状类型声明时的结构，所以我们只能用下面的两种语法，它们彼此是等价的：
```go
w = Wheel{Circle{Point{8, 8}, 5}, 20}

w = Wheel{
    Circle: Circle{
        Point:  Point{X: 8, Y: 8},
        Radius: 5,
    },
    Spokes: 20, // NOTE: trailing comma necessary here (and at Radius)
}
fmt.Printf("%#v\n", w)
// Output:
// Wheel{Circle:Circle{Point:Point{X:8, Y:8}, Radius:5}, Spokes:20}
```
Printf函数中`%v`参数包含的#副词，它表示用和Go语言类似的语法打印值。对于结构体类型来说，将包含每个成员的名字。

因为匿名成员也有一个隐式的名字，因此不能同时包含两个类型相同的匿名成员，这会导致名字冲突。同时，因为成员的名字是由其类型隐式地决定的，所有匿名成员也有可见性的规则约束。
匿名成员并不要求是结构体类型；其实任何命名的类型都可以作为结构体的匿名成员。

为什么要嵌入一个没有任何子成员类型的匿名成员类型呢？答案是匿名类型的方法集。
点运算符语法可以用于选择匿名成员嵌套的成员，**也可以用于访问它们的方法**。
实际上，**外层的结构体不仅仅是获得了匿名成员类型的所有成员，而且也获得了该类型导出的全部的方法。这个机制可以用于将一个有简单行为的对象组合成有复杂行为的对象。**组合是Go语言中面向对象编程的核心。

## JSON （CH 4.5）

标准库中的encoding/json、encoding/xml、encoding/asn1等包提供支持对数据交换协议的支持，Protocol Buffers的支持由github.com/golang/protobuf包提供。
JSON使用的是`\Uhhhh`转义数字来表示一个UTF-16编码。（译注：UTF-16和UTF-8一样是一种变长的编码，有些Unicode码点较大的字符需要用4个字节表示；而且UTF-16还有大端和小端的问题）

将一个Go语言结构转为JSON的过程叫编组（marshaling）。编组通过调用json.Marshal函数完成。json.MarshalIndent函数将产生整齐缩进的输出。在编码时，默认使用Go语言结构体的成员名字作为JSON的对象（通过reflect反射技术）。只有导出的结构体成员才会被编码。
编码的逆操作是解码，对应将JSON数据解码为Go语言的数据结构，Go语言中一般叫unmarshaling，通过json.Unmarshal函数完成。
```go
type Movie struct {
    Title  string
    //结构体成员Tag。Marshal和UnMarshal过程中，实现Go字段名称与Json字段名称的转换。
    Year   int  `json:"released"` 
    Color  bool `json:"color,omitempty"`
    Actors []string
}
```

http、url的例子。

### 文本和HTML模板（CH 4.6）

一个模板是一个字符串或一个文件，里面包含了一个或多个由双花括号包含的{{action}}对象。
每个actions都包含了一个用模板语言书写的表达式。

## 函数（CH 5）

### 函数声明（CH 5.1）

如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。如果一个函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值。

返回值也可以像形式参数一样被命名。在这种情况下，每个返回值（在函数开始执行时）被声明成一个局部变量，并根据该返回值的类型，将其初始化为0。 

如果一个函数在声明时，包含返回值列表，该函数必须以return语句结尾。

函数的类型被称为函数的标识符。如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型和标识符。形参和返回值的变量名不影响函数标识符。

每一次函数调用都必须按照声明顺序为所有参数提供实参（参数值）。在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义。

函数的形参和有名返回值作为函数最外层的局部变量，被存储在相同的词法块中。

实参通过值的方式传递，因此函数的形参是实参的拷贝。对形参进行修改不会影响实参。但是，如果实参包括引用类型，如指针，slice、map、function、channel等类型，实参可能会由于函数的简介引用被修改。

没有函数体的函数声明，表示该函数不是以Go实现的。

### 递归（CH 5.2）

Go语言使用可变栈，栈的大小按需增加(初始时很小)。这使得我们使用递归时不必考虑溢出和安全问题。

### 多返回值（CH 5.3）

虽然Go的垃圾回收机制会回收不被使用的内存，但是这不包括操作系统层面的资源，比如打开的文件、网络连接。因此我们必须显式的释放这些资源。

调用多返回值函数时，返回给调用者的是一组值，调用者必须显式的将这些值分配给变量。如果某个值不被使用，可以将其分配给blank identifier`_`。

不宜过度使用bare return。

### 错误（CH 5.4）

在Go的错误处理中，错误是软件包API和应用程序用户界面的一个重要组成部分，程序运行失败仅被认为是几个预期的结果之一。

内置的error是接口类型。nil意味着函数运行成功，non-nil表示失败。

在Go中，函数运行失败时会返回错误信息，这些错误信息被认为是一种预期的值而非异常（exception），这使得Go有别于那些将函数运行失败看作是异常的语言。虽然Go有各种异常机制，但这些机制仅被用在处理那些未被预料到的错误，即bug，而不是那些在健壮程序中应该被避免的程序错误。
Go这样设计的原因是，对于某个应该在控制流程中处理的错误，将这个错误以异常的形式抛出会混乱对错误的描述，这通常会导致一些糟糕的后果。当某个程序错误被当作异常处理后，这个错误会将堆栈根据信息返回给终端用户，这些信息复杂且无用，无法帮助定位错误。
正因此，Go使用控制流机制（如if和return）处理异常，这使得编码人员能更多的关注错误处理。

错误处理的5种策略。

### 函数值（CH 5.5）

在Go中，函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。对函数值（function value）的调用类似函数调用。

函数类型的零值是nil，如：`var f func(int) int`。调用值为nil的函数值会引起panic错误。
函数值可以与nil比较。但是函数值之间是不可比较的，也不能用函数值作为map的key。

函数值属于引用类型。Go使用闭包（closures）技术实现函数值，Go程序员也把函数值叫做**闭包**。

### 匿名函数（CH 5.6）

拥有函数名的函数只能在包级语法块中被声明。

函数字面量的语法和函数声明相似，区别在于func关键字后没有函数名。函数值字面量是一种表达式，它的值被成为匿名函数（anonymous function）。
函数字面量允许我们在使用时函数时，再定义它。
通过这种方式定义的函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量。
在下面的例子中，可以认为squaress是一个函数对象，其中包含变量x，每调用一次squares()生成一个新对象；也可以认为x是在堆中，每调用一次squares()，在堆中新分配一个x；具体看实现方式。
函数值不仅仅是一串代码，还记录了状态。在squares中定义的匿名内部函数可以访问和更新squares中的局部变量，这意味着匿名函数和squares中，存在变量引用。这就是函数值属于引用类型和函数值不可比较的原因（因为同样是squares中的匿名函数，不同时刻其实对应不同函数，因为x是func的一部分，而x在不同时刻是不一样的）。
Go使用闭包（closures）技术实现函数值，Go程序员也把函数值叫做**闭包**。
```go
func squares() func() int {
    var x int
    return func() int {
        x++
        return x * x
    }
}
func main() {
    f := squares()
    fmt.Println(f()) // "1"
    fmt.Println(f()) // "4"
    fmt.Println(f()) // "9"
    fmt.Println(f()) // "16"
}
```
通过这个例子，我们看到变量的生命周期不由它的作用域决定：squares返回后，变量x仍然隐式的存在于f中。

网页抓取的核心问题就是如何遍历图。

**函数值中记录的是循环（外部）变量的内存地址，而不是循环外部）变量某一时刻的值。**参考最后的例子。

### 可变参数（CH 5.7）

参数数量可变的函数称为为可变参数函数。
在声明可变参数函数时，需要在参数列表的**最后一个**参数类型之前加上省略符号“...”，这表示该函数会接收任意数量的**该类型**参数。只能是最后一个参数。
调用者隐式的创建一个数组，并将原始参数复制到数组中，再把数组的一个切片作为参数传给被调函数。如果原始参数已经是切片类型，我们该如何传递给函数？只需在最后一个参数后加上省略符。

### Deferred函数（CH 5.8）

在调用普通函数或方法前加上关键字defer，跟在defer后面的函数会被延迟执行。直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束。你可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。
调试复杂程序时，defer机制也常被用于记录何时进入和退出函数。

defer语句中的函数会在return语句更新返回值变量后再执行，又因为在函数中定义的匿名函数可以访问该函数包括返回值变量在内的所有变量，所以，对匿名函数采用defer机制，可以使其观察函数的返回值。

### Panic异常（CH 5.9）

一般而言，当panic异常发生时，程序会中断运行，并立即执行在该goroutine中被延迟的函数（defer 机制）。随后，程序崩溃并输出日志信息。日志信息包括panic value和函数调用的堆栈跟踪信息。panic value通常是某种错误信息。对于每个goroutine，日志信息中都会有与之相对的，发生panic时的函数调用堆栈跟踪信息。
直接调用内置的panic函数也会引发panic异常。

虽然Go的panic机制类似于其他语言的异常，但panic的适用场景有一些不同。由于panic会引起程序的崩溃，因此panic一般用于严重错误，如程序内部的逻辑不一致。
对于大部分漏洞，我们应该使用Go提供的错误机制，而不是panic，尽量避免程序的崩溃。在健壮的程序中，任何可以预料到的错误，如不正确的输入、错误的配置或是失败的I/O操作都应该被优雅的处理，最好的处理方式，就是使用Go的错误机制。

为了方便诊断问题，runtime包允许程序员输出堆栈信息。

runtime.Stack为何能输出已经被释放函数的信息。在Go的panic机制中，延迟函数的调用在释放堆栈信息之前。

### Recover捕获异常（CH 5.10）

如果在deferred函数中调用了内置函数recover，并且定义该defer语句的函数发生了panic异常，recover会使程序从panic中恢复，并返回panic value。导致panic异常的函数不会继续运行，但能正常返回。在未发生panic时调用recover，recover会返回nil。
```go
func Parse(input string) (s *Syntax, err error) {
	defer func() {
		if p := recover(); p != nil {
			err = fmt.Errorf("internal error: %v", p)
		}
	}()
	// ...parser...
}
```
在上例中，如果Parse发生panic异常，会被recover。

你不应该试图去恢复其他包引起的panic。公有的API应该将函数的运行失败作为error返回，而不是panic。同样的，你也不应该恢复一个由他人开发的函数引起的panic，比如说调用者传入的回调函数，因为你无法确保这样做是安全的。
安全的做法是有选择性的recover。换句话说，只恢复应该被恢复的panic异常，此外，这些异常所占的比例应该尽可能的低。
我们可以将panic value设置成特殊类型。在recover时对panic value进行检查，如果发现panic value是特殊类型，就将这个panic作为errror处理，如果不是，则按照正常的panic进行处理。

## 方法（CH 6）

方法是面向对象的概念。

## 方法声明（CH 6.1）

在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。
```go
package geometry

import "math"

type Point struct{ X, Y float64 }

// traditional function
func Distance(p, q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}

// same thing, but as a method of the Point type
func (p Point) Distance(q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}
```

上面的代码里那个附加的参数p，叫做方法的接收器(receiver)。在Go语言中，我们并不会像其它语言那样用this或者self作为接收器；我们可以任意的选择接收器的名字。
这种p.Distance的表达式叫做选择器（`.`运算符）。
每种类型都有其方法的命名空间。对于一个给定的类型，其内部的方法都必须有唯一的方法名，但是不同的类型却可以有同样的方法名。

`type Path []Point`。Path是一个命名的slice类型，而不是Point那样的struct类型，然而我们依然可以为它定义方法。在能够给任意类型定义方法这一点上，Go和很多其它的面向对象的语言不太一样。因此在Go语言里，我们为一些简单的数值、字符串、slice、map来定义一些附加行为很方便。方法可以被声明到任意类型，只要不是一个指针或者一个interface。

## 基于指针对象的方法（CH 6.2）

当这个接受者变量本身比较大时，我们就可以用其指针而不是对象来声明方法，如下：
```go
func (p *Point) ScaleBy(factor float64) {
	p.X *= factor
	p.Y *= factor
}
```
这个方法的名字是`(*Point).ScaleBy`。这里的括号是必须的；没有括号的话这个表达式可能会被理解为`*(Point.ScaleBy)`。

在现实的程序里，一般会约定如果Point这个类有一个指针作为接收器的方法，那么所有Point的方法都必须有一个指针接收器，即使是那些并不需要这个指针接收器的函数。（只是习惯，语法上不是必须的）

只有类型`(Point)`和指向他们的指针`(*Point)`，才是可能会出现在接收器声明里的两种接收器。此外，为了避免歧义，在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的，比如下面这个例子：
```go
type P *int
//函数f可能是 *int ，也可能是int类型的。
func (P) f() { /* ... */ } // compile error: invalid receiver type
```

译注：
* 不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换。
* 在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的问题：第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝（浅拷贝）。熟悉C或者C++的人这里应该很快能明白。

**nil也是一个合法的接收器类型**，比如map或者slice。

## 通过嵌入结构体来扩展类型（CH 6.3）











方法和接口的区别是什么？





















## 程序结构

if、for等语句，条件等可以不必用括号封起来。当然，如果避免误输入，封起来也是可以的。

### if

Go语言允许在if语句的条件中先赋值，再进行条件判断，这样err的生命周期仅在if语句内（[3],CH1.7）。

```go
if err := r.ParseForm(); err != nil {
	log.Print(err)
}
```

### for 

for循环有多种形式（[3],CH1.2）。如果连condition也省略了，这就变成一个无限循环。initalization如果存在，必须是一条简单语句（simple statement），即，短变量声明、自增语句、赋值语句或函数调用。
```go
for initialization; condition; post {
    // zero or more statements
}
for condition {
    // ...
}
for {
    // ...
}
for _, arg := range os.Args[1:] {
}
```

### switch

Go语言并不需要显式地在每一个case后写break，语言默认执行完case后的逻辑语句会自动退出（[3],CH1.8）。
Go语言里的switch还可以不带操作对象（译注：switch不带操作对象时默认用true值代替，然后将每个case的表达式和true值进行比较）；可以直接罗列多种条件，像其它语言里面的多个if else一样，下面是一个例子：
```go
func Signum(x int) int {
	switch {
	case x > 0:
		return +1
	default:
		return 0
	case x < 0:
		return -1
	}
}
```
switch也可以紧跟一个简短的变量声明，一个自增表达式、赋值语句，或者一个函数调用。


## 常用包

### 字符串操作

```go
strings.Join //连接字符串（CH1.2）
```

### I/O

```go
bufio.NewScanner //按行扫描。可以通过Split函数指定分隔方法（CH1.2）。
fmt //格式化io（CH1.2, CH1.3）
fmt.Printf("%d\t%s\n", n, line)
io.Copy
ioutil.Discard //类似/dev/null
```

CH4.3的例子`gopl.io/ch4/charcount`，对I/O有很好的演示。

### flag

类似于C++的google/flags。参考CH2.3.2。


## 代码格式

Go语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。（P3）
实际上，编译器会主动把特定符号后的换行符转换为分号, 因此换行符添加的位置会影响Go代码的正确解析（P3）。
举个例子, 函数的左括号`{`必须和`func`函数声明在同一行上, 且位于末尾，不能独占一行。




## 类与面向对象

Go不支持继承，没有类的层次结构。甚至没有“类”，通过Composition组合来构造复杂对象（Preface, xv）。

方法不仅可以定义在结构体上, 而且, 可以定义在任何用户自定义的类型上；并且, 具体类型和抽象类型（接口）之间的关系是隐式的，所以很多类型的设计者可能并不知道该类型到底实现了哪些接口。

## 包管理

Go语言的代码通过包（package）组织，包类似于其它语言里的库（libraries）或者模块（modules）。（P2）

Go的包可以有目录层次。

代码开始的`package main`表示该文件属于哪个包。

`import`声明导入需要的包。但**如果导入了不需要的包**，程序也会无法编译通过。（P3）
import声明必须跟在文件的package声明之后。

`main`包比较特殊。它定义了一个独立可执行的程序，而不是一个库。
在main包里的 main 函数也很特殊，它是整个程序执行时的入口。（P2）

包导入顺序并不重要；gofmt工具格式化时按照字母顺序对包名排序（P4）。

包导入有两种形式：
```go
import (
	"fmt"
	"os"
)
```

或
```go
import fmt
import os
```

按照惯例，我们在每个包的包声明前添加注释（P5）。


## 命令行参数

os.Args变量是一个字符串（string）的切片（CH1.2, P4）。
os.Args的第一个元素，os.Args[0], 是命令本身的名字；其它的元素则是程序启动时传给它的参数。


