
# Git对象模型

http://gitbook.liuhui998.com/index.html

## No delta, just snapshot

Git与大部分你熟悉的版本控制系统，如Subversion、CVS、Perforce之间的差别是很大的。
传统系统使用的是“增量文件系统”（Delta Storage systems）。它们存储是每次提交之间的差异。
而Git正好与之相反，它是保存的是每次提交的完整内容（snapshot）。它会在提交前根据要提交的内容计算SHA1哈希串值作为对象名，看仓库内是否有相同的对象，如果没有就将在“.git/objects"目录创建对应的对象，如果有就会重用已有的对象，以节约空间。

Git中如果两个文件内容相同，会共用同一个blob对象。

Git把它所管理的所有对象（blob，tree，commit，tag……），全部根据它们的内容生成SHA1哈希串值作为对象名。这样会带来的几个好处：
	1 Git只要比较对象名，就可以很快的判断两个对象的内容是否相同。
	2 因为在每个仓库（repository）的“对象名”的计算方法都完全一样，如果同样的内容存在两个不同的仓库中，就会存在相同的“对象名”。
	3 Git还可以通过检查对象内容的SHA1的哈希值和“对象名”是否匹配，来判断对象内容是否正确。

## Git对象

objects/ 这个目录非常重要，里面存储都是Git的数据对象,包括：提交（commits）, 树对象（trees），二进制对象（blobs），标签对象（tags）。

这些文件的内容其实是压缩的数据外加一个标注类型和长度的头。类型可以是提交对象（commit）、二进制对象（blob）、 树对象（tree）或者标签对象（tag）。

### blob对象

可以使用 `git show 6ff87c4664` 命令来查看一个blob对象里的内容。一个blob对象就是一块二进制数据，它没有指向任何东西或有任何其它属性，甚至连文件名都没有。

因为blob对象内容全部都是数据，如两个文件在一个目录树（或是一个版本仓库）中有同样的数据内容，那么它们将会共享同一个blob对象。Blob对象和其所对应的文件所在路径、文件名是否改被更改都完全没有关系。

### tree对象

一个tree对象有一串（bunch）指向blob对象或是其它tree对象的指针，它一般用来表示内容之间的目录层次关系。

`git show` 命令还可以用来查看tree对象，但是 `git ls-tree` 能让你看到更多的细节。如 `git ls-tree fb3a8bdd0ce`

一个tree对象包括一串（list）条目，每一个条目包括：mode（权限rwx）、对象类型、SHA1值和名字（这串条目是按名字排序的）。它用来表示一个目录树的内容。

Tree对象、blob对象和其它所有的对象一样，都用其内容的SHA1哈希值来命名的；只有当两个tree对象的内容完全相同（包括其所指向所有子对象）时，它的名字才会一样。

### commit对象

Git确实根据内容来生成名字的，而且同名（SHA1哈希串值）肯定会有相同内容。
但是提交对象（commit）和其它对象有点不一样，它里面会多一个时间戳（timestamp），所以在不同的时间生成的提交对象，即使内容完全一样其名字也不会相同。

commit对象指向一个tree对象, 并且带有相关的描述信息。一个树对象（tree）可以引用一个或多个二进制对象（blob），每个二进制对象都对应一个文件。 更进一步, 树对象也可以引用其他的树对象，从而构成一个目录层次结构。

可以用 `--pretty=raw` 参数来配合 `git show` 或 `git log` 去查看某个提交（commit）。如 `git show -s --pretty=raw 2be7fcb476`

一个提交（commit）由以下的部分组成：一个tree对象、父对象、作者、提交者注释。

**注意**: 一个提交（commit）本身并没有包括任何信息来说明其做了哪些修改; 所有的修改（changes）都是通过与父提交（parents）的内容比较而得出的。
值得一提的是, 尽管git可以检测到文件内容不变而路径改变的情况, 但是它不会去显式的记录文件的更名操作。（可以看一下 git diff 的 -M　参数的用法）





