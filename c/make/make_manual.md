# make manual

https://www.gnu.org/software/make/manual/

## Rule

https://www.gnu.org/software/make/manual/html_node/Rule-Introduction.html#Rule-Introduction
```make
target … : prerequisites …
	recipe
	…
	…
```

target
* A target is usually the name of a file that is generated by a program;
* examples of targets are executable or object files.
* A target can also be the name of an action to carry out, such as `clean`
* [Grouped Targets](https://www.gnu.org/software/make/manual/html_node/Multiple-Targets.html#Multiple-Targets): `&:`分隔target与prerequisite

prerequisite
* A prerequisite is a file that is used as input to create the target.
* A target often depends on several files.
* 如果prerequisite太多，可以用`\`断行
* [Order-only prerequisites](https://www.gnu.org/software/make/manual/html_node/Prerequisite-Types.html#Prerequisite-Types)

recipe
* A recipe is an action that make carries out.
* A recipe may have more than one command, either on the same line or each on its own line.
* 不同行的命令，处于不同shell
* 一个命令如果太长，可以用`\`断行
* 每行第一个字符必须是tab，除非显式设置变量`.RECIPEPREFIX`

[rule](https://www.gnu.org/software/make/manual/html_node/Rules.html#Rules)
* explains how and when to remake certain files which are the targets of the particular rule
* rule包括target，prerequisite和recipe是可选的。
* 例如，clean就没有prerequisite
* 如果没有recipe，就只检查prerequisite是否需要更新、并执行这些prerequisite的recipe(如果有的话)
* rule可以写为一行，prerequisite与recipe用分号分隔: `target : prerequisite ; recipe`

goal
* Goals are the targets that make strives ultimately to update
* 可能会有多个targets
* 在处理goals之前，需要先处理goals依赖的rules
* 处理一个rule时，如果target不存在，或者任一prerequisite比target新，就执行recipe
https://www.gnu.org/software/make/manual/html_node/How-Make-Works.html#How-Make-Works

recipe和prerequisite的自动推导
* make可以[自动推导prerequisite和recipe](https://www.gnu.org/software/make/manual/html_node/make-Deduces.html#make-Deduces)，比如target是`main.o`，就不必将`main.c`放入prerequisite，也不用写recipe
* `main.o : defs.h`，make遇到这个rule，会自动将`main.c`放入prerequisite，将cc加入recipe
https://www.gnu.org/software/make/manual/html_node/Implicit-Rules.html#Implicit-Rules

另一种风格的makefile: 按Prerequisite组织，target可能会多次“出现”
一个target file只能有一个recipe。一般情况下，如果指定多个，用最后一个，并打印错误信息。
https://www.gnu.org/software/make/manual/html_node/Combine-By-Prerequisite.html#Combine-By-Prerequisite
https://www.gnu.org/software/make/manual/html_node/Multiple-Rules.html#Multiple-Rules

## makefile

makefile包含[5种内容](https://www.gnu.org/software/make/manual/html_node/Makefile-Contents.html#Makefile-Contents)：
* explicit rules
* implicit rules
* variable definitions
* directives, and comments

[断行](https://www.gnu.org/software/make/manual/html_node/Splitting-Lines.html#Splitting-Lines)
* makefile以换行符作为语句结束，除非用`\`和换行符断行。
* recipe和非recipe行的断行有所不同。recipe的`\`会原封不动传给shell。
* Outside of recipe lines, backslash/newlines are converted into a single space character
* backslash/newlines前后的空白会被压缩
* 如果不想因换行添加空白，可以用trick:`$\\n`
https://www.gnu.org/software/make/manual/html_node/Splitting-Recipe-Lines.html#Splitting-Recipe-Lines

[makefile name search](https://www.gnu.org/software/make/manual/html_node/Makefile-Names.html#Makefile-Names)
* GNUmakefile
* makefile
* Makefile (recommended)
可以用`-f`或`--file`指定文件名。多个选项指定的文件名会按顺序拼接。

makefile的处理分为两个阶段。有些操作是deferred，有些是immediate
https://www.gnu.org/software/make/manual/html_node/Reading-Makefiles.html#Reading-Makefiles

## Rule

recipe默认的shell是`sh`
https://www.gnu.org/software/make/manual/html_node/Rule-Syntax.html#Rule-Syntax

[wildcard characters](https://www.gnu.org/software/make/manual/html_node/Wildcards.html#Wildcards)
* `*`
* `?`
* `[…]`
* `~`: HOME dir
* Wildcard expansion is performed by make automatically in targets and in prerequisites
* In recipes, the shell is responsible for wildcard expansion
* In other contexts, wildcard expansion happens only if you request it explicitly with the wildcard function
* The special significance of a wildcard character can be turned off by preceding it with a backslash
* [Wildcard expansion does not happen when you define a variable.](https://www.gnu.org/software/make/manual/html_node/Wildcard-Examples.html#Wildcard-Examples)可用wildcard函数。
* 用于prerequisites时，会原封不动使用原始字符串，如`*.o`，[如果没有任何文件符合规则](https://www.gnu.org/software/make/manual/html_node/Wildcard-Pitfall.html#Wildcard-Pitfall)
* 其它相关主题
  * [Static Pattern Rules](https://www.gnu.org/software/make/manual/html_node/Static-Usage.html#Static-Usage)
  * [Pattern Rules](https://www.gnu.org/software/make/manual/html_node/Pattern-Rules.html#Pattern-Rules)

vpath/VPATH: Search Path for All Prerequisites
https://www.gnu.org/software/make/manual/html_node/General-Search.html#General-Search
https://www.gnu.org/software/make/manual/html_node/Selective-Search.html#Selective-Search
https://www.gnu.org/software/make/manual/html_node/Search-Algorithm.html#Search-Algorithm

[Static pattern rules](https://www.gnu.org/software/make/manual/html_node/Static-Pattern.html#Static-Pattern)
* 用pattern `%`列出多个targes，并根据target名字构造prerequisite名字，每个target对应的prerequisite名字可以不一样。
* 必须是3段: `$(objects): %.o: %.c`

## Recipe

[Recipe Syntax](https://www.gnu.org/software/make/manual/html_node/Recipe-Syntax.html#Recipe-Syntax)
* makefile中大部分内容都遵循make语法。但是recipe遵循shell语法。
* make对recipe文本的一种改动，是把`\`分隔的多行合并为一行、作为一个task提交给shell。注意，`\`和换行符并不会删除，一并提交给shell解释。
* make对recipe文本的一种改动，是expand variable: `$`是makefle变量，`$$`是shell变量。[参考](https://www.gnu.org/software/make/manual/html_node/Variables-in-Recipes.html#Variables-in-Recipes)
* 以tab起始的空行不是普通空行，而是空的recipe
* recipe中的注释会原封不动传给shell。默认是sh
* 如果recipe以`@`起始，则[该命令不会由make输出，但仍会传给shell执行。](https://www.gnu.org/software/make/manual/html_node/Echoing.html#Echoing)

[Recipe Execution](https://www.gnu.org/software/make/manual/html_node/Execution.html#Execution)
* 通常情况下，每个recipe语句(逻辑行)用独立的shell执行
* unless the `.ONESHELL` special target is in effect
* `.ONESHELL`的影响范围是整个makefile？
* 如果启用`.ONESHELL`，make只处理recipe的第一行的首特殊字符，如`@+-`，[后续行的特殊字符会一并传给shell](https://www.gnu.org/software/make/manual/html_node/One-Shell.html#One-Shell)
* 设置makefile变量SHELL，可以[修改默认shell](https://www.gnu.org/software/make/manual/html_node/Choosing-the-Shell.html#Choosing-the-Shell)
* `.SHELLFLAGS`可以设置shell参数
* make启动环境中的变量，makefile中定义的变量，都会[export给recipe](https://www.gnu.org/software/make/manual/html_node/Environment.html#Environment)

[Errors in Recipes](https://www.gnu.org/software/make/manual/html_node/Errors.html#Errors)
* 以`-`开头的recipe line，会忽略其执行错误。`-`不会传给shell

Recursive Use of make
* [Recursive make commands should always use the variable MAKE](https://www.gnu.org/software/make/manual/html_node/MAKE-Variable.html#MAKE-Variable)

## [Variables](https://www.gnu.org/software/make/manual/html_node/Using-Variables.html#Using-Variables)

[简介demo](https://www.gnu.org/software/make/manual/html_node/Variables-Simplify.html#Variables-Simplify)

[The Two Flavors of Variables](https://www.gnu.org/software/make/manual/html_node/Flavors.html#Flavors)
* `=`: recursively expanded variable
* `:=`或`::=`: Simply expanded variables
* `?=`: conditional variable assignment operator, 只有当变量之前未定义时才生效
* `!=`: [执行shell脚本并将输出赋值给变量](https://www.gnu.org/software/make/manual/html_node/Setting.html#Setting)
* `+=`: [Appending More Text to Variables](https://www.gnu.org/software/make/manual/html_node/Appending.html#Appending)

[如果没有设置，变量默认值通常是空字符串。](https://www.gnu.org/software/make/manual/html_node/Setting.html#Setting)
Most variable names are considered to have the empty string as a value if you have never set them.

[define只是定义了一个变量](https://www.gnu.org/software/make/manual/html_node/Multi_002dLine.html#Multi_002dLine)

[Substitution References](https://www.gnu.org/software/make/manual/html_node/Substitution-Refs.html#Substitution-Refs):
```make
foo := a.o b.o l.a c.o
bar := $(foo:.o=.c)
# bar is: a.c b.c l.a c.c
```

## Implicit Rules 

[Each implicit rule has a target pattern and prerequisite patterns.](https://www.gnu.org/software/make/manual/html_node/Using-Implicit.html#Using-Implicit)
There may be many implicit rules with the same target pattern.

[You define an implicit rule by writing a pattern rule.](https://www.gnu.org/software/make/manual/html_node/Pattern-Rules.html#Pattern-Rules)

[Introduction to Pattern Rules](https://www.gnu.org/software/make/manual/html_node/Pattern-Intro.html#Pattern-Intro)
* pattern rule target的prerequisite如果不带`%`，则适用于每个匹配的target
* Pattern rules are always treated as grouped targets

[Variables Used by Implicit Rules](https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html)
* CC
* CXX
* CPP
* CFLAGS
* CXXFLAGS
* ...

关于CFLAGS等变量的来龙去脉: 最早来自于make，automake等也接受这些变量。
https://stackoverflow.com/questions/16044020/
https://forum.golangbridge.org/t/cflags-ldflags-documentation-somewhere/4520
https://wiki.gentoo.org/wiki/GCC_optimization/en
https://wiki.gentoo.org/wiki/GCC_optimization/en

## Summary of Options.

* `-j`: the number of recipes to execute at once。如果后面没有整数参数，则并发recipe的个数没有限制。
* `-n`或`--just-print`只会打印recipe命令，不会执行。

## 疑问

remake makefile


